import { Pair, KoconutPair, KoconutCollection, KoconutEquatable, KoconutComparable } from "../../../../module.internal";
export declare class KoconutSet<DataType> extends KoconutCollection<DataType, Set<DataType>> {
    static from<DataType>(source: Iterable<DataType>): KoconutSet<DataType>;
    static of<DataType>(...data: DataType[]): KoconutSet<DataType>;
    validiate(data: Set<DataType> | null): Promise<void>;
    private static fromCollection;
    associateByTo<KeyType, ValueType = DataType>(destination: Map<KeyType, ValueType>, keySelector: (element: DataType) => KeyType | Promise<KeyType>, valueTransform?: ((element: DataType) => ValueType | Promise<ValueType>) | null, keySelectorThisArg?: any, valueTransformThisArg?: any): KoconutSet<DataType>;
    associateTo<KeyType, ValueType>(destination: Map<KeyType, ValueType>, transform: (element: DataType) => [KeyType, ValueType] | Pair<KeyType, ValueType> | KoconutPair<KeyType, ValueType> | Pair<KeyType, ValueType> | Promise<[KeyType, ValueType] | KoconutPair<KeyType, ValueType>>, thisArg?: any): KoconutSet<DataType>;
    associateWithTo<ValueType>(destination: Map<DataType, ValueType>, valueSelector: (element: DataType) => ValueType | Promise<ValueType>, thisArg?: any): KoconutSet<DataType>;
    distinct(): KoconutSet<DataType>;
    distinctBy<KeyType, EuqatableKeyType extends KoconutEquatable>(selector: (element: DataType) => KeyType | EuqatableKeyType | Promise<KeyType>, thisArg?: any): KoconutSet<DataType>;
    drop(n: number): KoconutSet<DataType>;
    dropLast(n: number): KoconutSet<DataType>;
    dropLastWhile(predicate: (element: DataType) => boolean | Promise<boolean>, thisArg?: any): KoconutSet<DataType>;
    dropWhile(predicate: (element: DataType) => boolean | Promise<boolean>, thisArg?: any): KoconutSet<DataType>;
    filter(predicate: (element: DataType) => boolean | Promise<boolean>, thisArg?: any): KoconutSet<DataType>;
    filterIndexed(predicate: (index: number, element: DataType) => boolean | Promise<boolean>, thisArg?: any): KoconutSet<DataType>;
    filterIndexedTo(destination: Array<DataType> | Set<DataType>, predicate: (index: number, element: DataType) => boolean | Promise<boolean>, thisArg?: any): KoconutSet<DataType>;
    filterNot(predicate: (element: DataType) => boolean | Promise<boolean>, thisArg?: any): KoconutSet<DataType>;
    filterNotNull(): KoconutSet<DataType>;
    filterNotNullTo(destination: Array<DataType> | Set<DataType>): KoconutSet<DataType>;
    filterNotTo(destination: Array<DataType> | Set<DataType>, predicate: (element: DataType) => boolean | Promise<boolean>, thisArg?: any): KoconutSet<DataType>;
    filterTo(destination: Array<DataType> | Set<DataType>, predicate: (element: DataType) => boolean | Promise<boolean>, thisArg?: any): KoconutSet<DataType>;
    flatMapIndexedTo<ResultDataType>(destination: Array<ResultDataType> | Set<ResultDataType>, transform: (index: number, element: DataType) => Iterable<ResultDataType> | Promise<Iterable<ResultDataType>>, thisArg?: any): KoconutSet<DataType>;
    flatMapTo<ResultDataType>(destination: Array<ResultDataType> | Set<ResultDataType>, transform: (element: DataType) => Iterable<ResultDataType> | Promise<Iterable<ResultDataType>>, thisArg?: any): KoconutSet<DataType>;
    groupByTo<KeyType, ValueType = DataType>(destination: Map<KeyType, Array<ValueType>>, keySelector: (element: DataType) => KeyType | Promise<KeyType>, valueTransform?: ((element: DataType) => ValueType | Promise<ValueType>) | null, keySelectorThisArg?: any, valueTransformThisArg?: any): KoconutSet<DataType>;
    mapIndexedNotNullTo<ResultDataType>(destination: Array<ResultDataType> | Set<ResultDataType>, transform: (index: number, element: DataType) => ResultDataType | void | null | undefined | Promise<ResultDataType | void | null | undefined>, thisArg?: any): KoconutSet<DataType>;
    mapIndexedTo<ResultDataType>(destination: Array<ResultDataType> | Set<ResultDataType>, transform: (index: number, element: DataType) => ResultDataType | Promise<ResultDataType>, thisArg?: any): KoconutSet<DataType>;
    mapNotNullTo<ResultDataType>(destination: Array<ResultDataType> | Set<ResultDataType>, transform: (element: DataType) => ResultDataType | Promise<ResultDataType>, thisArg?: any): KoconutSet<DataType>;
    mapTo<ResultDataType>(destination: Array<ResultDataType> | Set<ResultDataType>, transform: (element: DataType) => ResultDataType | Promise<ResultDataType>, thisArg?: any): KoconutSet<DataType>;
    minus(element: DataType): KoconutSet<DataType>;
    minus(elements: Iterable<DataType>): KoconutSet<DataType>;
    minusElement(element: DataType): KoconutSet<DataType>;
    onEach(action: (element: DataType) => boolean | void | Promise<boolean | void>, thisArg?: any): KoconutSet<DataType>;
    onEachIndexed(action: (index: number, element: DataType) => boolean | void | Promise<boolean | void>, thisArg?: any): KoconutSet<DataType>;
    plus(element: DataType): KoconutSet<DataType>;
    plus(elements: Iterable<DataType>): KoconutSet<DataType>;
    plusElement(element: DataType): KoconutSet<DataType>;
    reversed(): KoconutSet<DataType>;
    shuffled(): KoconutSet<DataType>;
    sortedBy(selector: (element: DataType) => number | string | KoconutComparable | Promise<number | string | KoconutComparable>, thisArg?: any): KoconutSet<DataType>;
    sortedByDescending(selector: (element: DataType) => number | string | KoconutComparable | Promise<number | string | KoconutComparable>, thisArg?: any): KoconutSet<DataType>;
    sortedWith(comparator: (front: DataType, rear: DataType) => number | Promise<number>, thisArg?: any): KoconutSet<DataType>;
    take(n: number): KoconutSet<DataType>;
    takeLast(n: number): KoconutSet<DataType>;
    takeLastWhile(predicate: (element: DataType) => boolean | Promise<boolean>, thisArg?: any): KoconutSet<DataType>;
    takeWhile(predicate: (element: DataType) => boolean | Promise<boolean>, thisArg?: any): KoconutSet<DataType>;
}
